/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package pl.polsl.vigenereCipher.model;

import pl.polsl.vigenereCipher.exception.EmptyStringException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * @author Bartosz Dera
 * Class implementing VigenereModel object
 */
public class VigenereModel {

    /**
     * Constructor of VigenereModel class.
     * @param secretLetter String object of secret letter.
     * @param textToCode String object of text to encode.
     */
    public VigenereModel(String secretLetter, String textToCode) {
        this.secretLetter = secretLetter;
        this.textToCode = textToCode;
    }

    public VigenereModel(){}
    /**
     * Encoded message, generated by the encodeMessage() method.
     */
    private final EncodedMessage<String> encodedMessage = new EncodedMessage<>();
    
    /**
     * Key, used by encodeMessage method to encrypt the message.
     */
    private String encryptionKey;
    
    /**
     * Secret letter given by user.
     * Instered on the beginning of the encryptionKey attribute.
     */
    private String secretLetter;
    
    /**
     * Message given by user to encode.
     */
    private String textToCode;
    
    /**
     * Method for creating key used to encode message.
     */
    private void createKey(){
        encryptionKey = secretLetter + shiftRight(textToCode);
    }
    
    /**
     * Method moving characters in String one time to right
     * with leaving Space-value chars on same indexes.
     * Last character of String is removed.
     * @param text Text of value of textToCode
     * @return Value of second part to create encryptionKey
     */
    public String shiftRight(String text)
    {
        text = text.strip();
        if(text.isEmpty()) { return "";}

        String[] strings = text.split(" ");

        String lastCharacter = "";
        for (int i = 0; i < strings.length; i++)
        {
            String currentText = lastCharacter + strings[i];
            lastCharacter = currentText.substring(currentText.length() - 1);
            strings[i] = currentText.substring(0, currentText.length() - 1);
        }
        return String.join(" ", strings);
    }
    
    /**
     * Method responsible for encoding given message.
     */
    public void encodeMessage() throws EmptyStringException{
        ArrayList<Character> charEncodedMessage = new ArrayList<Character>();
        createKey();
        
        if(textToCode.isEmpty()){
            throw new EmptyStringException("CiÄ…g do zakodowania jest pusty!");
        }

        List<List<Character>> cipherTable = new ArrayList<>();
        createCipherTable((ArrayList<List<Character>>) cipherTable);

        Character spaceChar = ' ';
        
        for(int i = 0; i < textToCode.length(); i++) {
            if( textToCode.charAt(i) == ' ' ){
                charEncodedMessage.add(' ');
                continue;
            }
            else if(Character.getNumericValue(textToCode.charAt(i)) > 35
                    || Character.getNumericValue(textToCode.charAt(i)) < 10 ){
                charEncodedMessage.add(textToCode.charAt(i));
                continue;
            }

            int keyValue;
            if(Character.getNumericValue(encryptionKey.charAt(i)) > 35
                    || Character.getNumericValue(encryptionKey.charAt(i)) < 10){
                keyValue = 0;
            }
            else {
                keyValue = Character.getNumericValue(encryptionKey.charAt(i)) - 10; 
            }
            // Read char value and then get numeric value of character,
            // substitute by 10 (getNumericValue also reads values of 0-9 numbers)
//            charEncodedMessage.add(cipherTable[Character.getNumericValue(textToCode.charAt(i)) - 10][keyValue]);
            charEncodedMessage.add(cipherTable.get(Character.getNumericValue(textToCode.charAt(i)) - 10).get(keyValue));
        }
        
        encodedMessage.setTextEncodedMessageFromArrayList(charEncodedMessage);
//        encodedMessage.setTextEncodedMessage( LAMBDA EXPR );  // <--- 99% that I can insert lambda expression here, but how?!?
    }
    
    /**
     * Gets the atribute encodedMessage.
     * @return Encoded message
     */
    public String getEncodedMessage(){
        return (String) encodedMessage.getTextEncodedMessage();
    }
    
    /**
     * Gets the atribute textToCode.
     * @return String object with value of textToCode.
     */
    public String getTextToCode(){
        return this.textToCode;
    }
    
    /**
     * Sets the atribute textToCode. Additionally removes all spaces before proper textToCode.
     * @param text String value to be textToCode
     */
    public void setTextToCode(String text){
        this.textToCode = text.trim();
    }
    
    /**
     * Gets the value of attribute secretLetter
     * @return String object with value of secretLetter
     */
    public String getSecretLetter(){
        return this.secretLetter;
    }
    
    /**
     * Sets the attribute secretLetter.
     * @param secretLetter String value to be secretLetter
     */
    public void setSecretLetter(String secretLetter) throws EmptyStringException{
        if(secretLetter.isEmpty()){
            throw new EmptyStringException("Klucz niepoprawny!");
        }

        while(secretLetter.charAt(0) == ' ' 
                || Character.getNumericValue(secretLetter.charAt(0)) > 35
                || Character.getNumericValue(secretLetter.charAt(0)) < 10){

            secretLetter = secretLetter.substring(1);

            if(secretLetter.isEmpty()){
                throw new EmptyStringException("Klucz niepoprawny!");
            }
        }
        this.secretLetter = Character.toString(secretLetter.charAt(0));
    }
    
    /**
     * Initialize cipherTable with uppercase letters.
     * @param cipherTable Table to bo initialized
     */
    private void createCipherTable(ArrayList<List<Character>> cipherTable){
        for (int i = 0; i < 26; i++) {
//            cipherTable.add(new ArrayList<Character>());
//            for (int j = 0; j < 26; j++) {
//                cipherTable.get(i).add((char)(65 + ((i+j) % 26)));
//            }
            cipherTable.add(IntStream.concat(IntStream.range(i, 26), IntStream.range(0, i))
                    .mapToObj(c -> (char) (65 + c))
                    .collect(Collectors.toList()));
        }
    }
}

/**
 * Class implementing VigenereModel object
 * @param <T> Generic type of class
 */
class EncodedMessage<T>{
    private T textEncodedMessage;

    public EncodedMessage(){}

    /**
     * Getter of textEncodedMessage.
     * @return T object of textEncodedMessage.
     */
    public T getTextEncodedMessage(){
        return this.textEncodedMessage;
    }

    /**
     * Sets the attribute of textEncodedMessage.
     * @param temp Parameter of T-type to be set as textEncodedMessage.
     */
    public void setTextEncodedMessage(T temp){
        this.textEncodedMessage = temp;
    };

    /**
     * Method to cast array list of characters to string.
     * @param temp Collection of characters
     */
    public void setTextEncodedMessageFromArrayList(ArrayList<Character> temp){
        StringBuilder builder = new StringBuilder(temp.size());
        temp.forEach(characters -> builder.append(characters));
//        for(Character ch: temp){
//            builder.append(ch);
//        }
        this.textEncodedMessage = (T) builder.toString();
    };
}