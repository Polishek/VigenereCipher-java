/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package pl.polsl.vigenere.cipher;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @author Bartosz Dera
 * @version 1.0
 * Class implementing VigenereModel object
 */
public class VigenereModel {
    /**
     * Encoded message, generated by the encodeMessage() method.
     */
    private final EncodedMessage encodedMessage = new EncodedMessage();
    
    /**
     * Key, used by encodeMessage method to encrypt the message.
     */
    private String encryptionKey;
    
    /**
     * Secret letter given by user.
     * Instered on the beginning of the encryptionKey attribute.
     */
    private String secretLetter;
    
    /**
     * Message given by user to encode.
     */
    private String textToCode;
    
    /**
     * Method for creating key used to encode message.
     */
    private void createKey(){
        encryptionKey = secretLetter + shiftRight(textToCode);
    }
    
    /**
     * Method moving characters in String one time to right
     * with leaving Space-value chars on same indexes.
     * Last character of String is removed.
     * @param text Text of value of textToCode
     * @return Value of second part to create encryptionKey
     */
    public String shiftRight(String text)
    {
        if(text.isEmpty()) { return "";}
        
        String[] strings = text.split(" ");

        String lastCharacter = "";
        for (int i = 0; i < strings.length; i++)
        {
            String currentText = lastCharacter + strings[i];
            lastCharacter = currentText.substring(currentText.length() - 1);
            strings[i] = currentText.substring(0, currentText.length() - 1);
        }
        return String.join(" ", strings);
    }
    
    /**
     * Method responsible for encoding given message.
     */
    public void encodeMessage() throws EmptyStringException{
        ArrayList<Character> charEncodedMessage = new ArrayList<Character>();
        createKey();
        
        if(textToCode.isEmpty()){
            throw new EmptyStringException("CiÄ…g do zakodowania jest pusty!");
        }

        ArrayList<ArrayList<Character>> cipherTable = new ArrayList<ArrayList<Character>>();
//        char[][] cipherTable1 = new char[26][26];
        createCipherTable(cipherTable);

        Character spaceChar = ' ';
        
        for(int i = 0; i < textToCode.length(); i++) {
            if( textToCode.charAt(i) == ' ' ){
                charEncodedMessage.add(' ');
                continue;
            }
            else if(Character.getNumericValue(textToCode.charAt(i)) > 35
                    || Character.getNumericValue(textToCode.charAt(i)) < 10 ){
                charEncodedMessage.add(textToCode.charAt(i));
                continue;
            }

            int keyValue;
            if(Character.getNumericValue(encryptionKey.charAt(i)) > 35
                    || Character.getNumericValue(encryptionKey.charAt(i)) < 10){
                keyValue = 0;
            }
            else {
                keyValue = Character.getNumericValue(encryptionKey.charAt(i)) - 10; 
            }
            // Read char value and then get numeric value of character,
            // substitute by 10 (getNumericValue also reads values of 0-9 numbers)
//            charEncodedMessage.add(cipherTable[Character.getNumericValue(textToCode.charAt(i)) - 10][keyValue]);
            charEncodedMessage.add(cipherTable.get(Character.getNumericValue(textToCode.charAt(i)) - 10).get(keyValue));
        }
        
        encodedMessage.setTextEncodedMessageFromArrayList(charEncodedMessage);
//        encodedMessage.setTextEncodedMessage( LAMBDA EXPR );  // <--- 99% that I can insert lambda expression here, but how?!?
    }
    
    /**
     * Gets the atribute encodedMessage.
     * @return Encoded message
     */
    public String getEncodedMessage(){
        return encodedMessage.getTextEncodedMessage();
    }
    
    /**
     * Gets the atribute textToCode.
     * @return String object with value of textToCode.
     */
    public String getTextToCode(){
        return this.textToCode;
    }
    
    /**
     * Sets the atribute textToCode. Additionally removes all spaces before proper textToCode.
     * @param text String value to be textToCode
     */
    public void setTextToCode(String text){
//        while(!text.isEmpty() && text.charAt(0) == ' '){
//            text = text.substring(1);
//        }
        
        
        this.textToCode = text.trim();
    }
    
    /**
     * Gets the value of attribute secretLetter
     * @return String object with value of secretLetter
     */
    public String getSecretLetter(){
        return this.secretLetter;
    }
    
    /**
     * Sets the attribute secretLetter.
     * @param secretLetter String value to be secretLetter
     */
    public void setSecretLetter(String secretLetter) throws EmptyStringException{
        if(secretLetter.isEmpty()){
            throw new EmptyStringException("Klucz niepoprawny!");
        }

        while(secretLetter.charAt(0) == ' ' 
                || Character.getNumericValue(secretLetter.charAt(0)) > 35
                || Character.getNumericValue(secretLetter.charAt(0)) < 10){

            secretLetter = secretLetter.substring(1);

            if(secretLetter.isEmpty()){
                throw new EmptyStringException("Klucz niepoprawny!");
            }
        }
        this.secretLetter = Character.toString(secretLetter.charAt(0));
    }
    
    /**
     * Initialize cipherTable with uppercase letters.
     * @param cipherTable Table to bo initialized
     */
    private void createCipherTable(ArrayList<ArrayList<Character>> cipherTable){
        for (int i = 0; i < 26; i++) {
            cipherTable.add(new ArrayList<Character>());
            for (int j = 0; j < 26; j++) {
                cipherTable.get(i).add((char)(65 + ((i+j) % 26)));
            }
        }
    }
}

class EncodedMessage{
    private String textEncodedMessage;
    
    public EncodedMessage(){}
    
    public String getTextEncodedMessage(){
        return this.textEncodedMessage;
    }
    
    public void setTextEncodedMessage(String temp){
        this.textEncodedMessage = temp;
    };

    public void setTextEncodedMessageFromArrayList(ArrayList<Character> temp){
        StringBuilder builder = new StringBuilder(temp.size());
        for(Character ch: temp){
            builder.append(ch);
        }
        this.textEncodedMessage = builder.toString();
    };
}