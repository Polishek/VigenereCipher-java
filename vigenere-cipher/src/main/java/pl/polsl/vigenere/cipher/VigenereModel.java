/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package pl.polsl.vigenere.cipher;

import java.util.Arrays;

/**
 * @author Bartosz Dera
 * @version 1.0
 * Class implementing VigenereModel object
 */
public class VigenereModel {
    /**
     * Encoded message, generated by the encodeMessage() method.
     */
    private String encodedMessage;
    
    /**
     * Key, used by encodeMessage method to encrypt the message.
     */
    private String encryptionKey;
    
    /**
     * Secret letter given by user.
     * Instered on the beginning of the encryptionKey attribute.
     */
    private String secretLetter;
    
    /**
     * Message given by user to encode.
     */
    private String textToCode;
    
    /**
     * Method for creating key used to encode message.
     */
    private void createKey(){
        encryptionKey = secretLetter + shiftRight(textToCode);
    }
    
    /**
     * Method moving characters in String one time to right
     * with leaving Space-value chars on same indexes.
     * Last character of String is removed.
     * @param text Text of value of textToCode
     * @return Value of second part to create encryptionKey
     */
    public String shiftRight(String text)
    {
        if(text.isEmpty()) { return "";}
        
        String[] strings = text.split(" ");

        String lastCharacter = "";
        for (int i = 0; i < strings.length; i++)
        {
            String currentText = lastCharacter + strings[i];
            lastCharacter = currentText.substring(currentText.length() - 1);
            strings[i] = currentText.substring(0, currentText.length() - 1);
        }
        return String.join(" ", strings);
    }
    
    /**
     * Method responsible for encoding given message.
     */
    public void encodeMessage() throws EmptyStringException{
        char[] charEncodedMessage = new char[textToCode.length()];
        createKey();
        
        if(encryptionKey.isEmpty() || textToCode.isEmpty()){
            throw new EmptyStringException("CiÄ…g do zakodowania lub klucz jest pusty!");
        }
        
        char[][] cipherTable=new char[26][26];
        createCipherTable(cipherTable);
        Character spaceChar = ' ';
        
        for(int i = 0; i < textToCode.length(); i++) {
            if( textToCode.charAt(i) == ' ' ){
                charEncodedMessage[i] = ' ';
                continue;
            }
            else if(Character.getNumericValue(textToCode.charAt(i)) > 26 || Character.getNumericValue(textToCode.charAt(i)) < 10 ){
                charEncodedMessage[i] = textToCode.charAt(i);
                continue;
            }
            
            
            int keyValue;
            if(Character.getNumericValue(encryptionKey.charAt(i)) > 26 || Character.getNumericValue(encryptionKey.charAt(i)) < 10){
                keyValue = 0;
            }
            else {
                keyValue = Character.getNumericValue(encryptionKey.charAt(i)) - 10; 
            }
            //Read char value and then get numeric value of character, substitute by 10 (getNumericValue also reads values of 0-9 numbers)
            charEncodedMessage[i] = cipherTable[Character.getNumericValue(textToCode.charAt(i)) - 10][keyValue];
        }

        encodedMessage = new String(charEncodedMessage);
    }
    
    /**
     * Gets the atribute encodedMessage.
     * @return Encoded message
     */
    public String getEncodedMessage(){
        return encodedMessage;
    }
    
    /**
     * Gets the atribute textToCode.
     * @return String object with value of textToCode.
     */
    public String getTextToCode(){
        return this.textToCode;
    }
    
    /**
     * Sets the atribute textToCode. Additionally removes all spaces before proper textToCode.
     * @param text String value to be textToCode
     */
    public void setTextToCode(String text){
//        while(!text.isEmpty() && text.charAt(0) == ' '){
//            text = text.substring(1);
//        }
        
        
        this.textToCode=text.trim();
    }
    
    /**
     * Gets the value of attribute secretLetter
     * @return String object with value of secretLetter
     */
    public String getSecretLetter(){
        return this.secretLetter;
    }
    
    /**
     * Sets the attribute secretLetter.
     * @param secretLetter String value to be secretLetter
     */
    public void setSecretLetter(String secretLetter){
        while(secretLetter.charAt(0) == ' ' || Character.getNumericValue(secretLetter.charAt(0)) > 26 || Character.getNumericValue(secretLetter.charAt(0)) < 10){
            secretLetter = secretLetter.substring(1);
        }
        this.secretLetter = Character.toString(secretLetter.charAt(0));
    }
    
    /** 
     * Method to remove last character from given String.
     * @param s String to have last character removed
     * @return substring os String without last character
     */
    private String removeLastChar(String s){  
        return s.substring(0, s.length() - 1);  
    }
    
    /**
     * Initialize cipherTable with uppercase letters.
     * @param cipherTable Table to bo initialized
     */
    private void createCipherTable(char[][] cipherTable){
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                cipherTable[i][j]=(char)(65 + ((i+j)%26));
            }
        }
    }
    
    /**
     * Method analyzing parameters and executed when given in command line.
     * @param args Command line
     */
    public void setParamFromCommandLine(String[] args){
        for (int i = 0; i < args.length; i++) {
            if(args[i].equalsIgnoreCase("-key")){
                setSecretLetter(args[i+1]);
            }
            else if(args[i].equalsIgnoreCase("-message")){
                    String[] temp = Arrays.copyOfRange(args, i+1, args.length);
                    
                    this.textToCode=readTextToCode(temp);
                }
        }
    }
    
    /**
     * Method reading whole textToCode string from command line
     * @param temp Array of Strings to be analyzed
     * @return textToCode
     */
    private String readTextToCode(String[] temp){
        int i = 0;
        String result = ""; //is initialization needed?
        while(i < temp.length){
            if(temp[i].charAt(0) == '-'){
                break;
            }
            result = result.concat(temp[i]+' ');
            i++;
        }
        
        return result;
    }
}