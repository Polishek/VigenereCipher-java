/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package pl.polsl.vigenere.cipher;

import java.util.Arrays;

/**
 * @author Bartosz Dera
 * @version 1.0
 * Class implementing VigenereModel object
 */
public class VigenereModel {
    /**
     * Encoded message, generated by the encodeMessage() method.
     */
    private final EncodedMessage encodedMessage = new EncodedMessage();
    
    /**
     * Key, used by encodeMessage method to encrypt the message.
     */
    private String encryptionKey;
    
    /**
     * Secret letter given by user.
     * Instered on the beginning of the encryptionKey attribute.
     */
    private String secretLetter;
    
    /**
     * Message given by user to encode.
     */
    private String textToCode;
    
    /**
     * Method for creating key used to encode message.
     */
    private void createKey(){
        encryptionKey = secretLetter + shiftRight(textToCode);
    }
    
    /**
     * Method moving characters in String one time to right
     * with leaving Space-value chars on same indexes.
     * Last character of String is removed.
     * @param text Text of value of textToCode
     * @return Value of second part to create encryptionKey
     */
    public String shiftRight(String text)
    {
        if(text.isEmpty()) { return "";}
        
        String[] strings = text.split(" ");

        String lastCharacter = "";
        for (int i = 0; i < strings.length; i++)
        {
            String currentText = lastCharacter + strings[i];
            lastCharacter = currentText.substring(currentText.length() - 1);
            strings[i] = currentText.substring(0, currentText.length() - 1);
        }
        return String.join(" ", strings);
    }
    
    /**
     * Method responsible for encoding given message.
     */
    public void encodeMessage() throws EmptyStringException{
        char[] charEncodedMessage = new char[textToCode.length()];
        createKey();
        
        if(encryptionKey.isEmpty() || textToCode.isEmpty()){
            throw new EmptyStringException("CiÄ…g do zakodowania lub klucz jest pusty!");
        }
        
        char[][] cipherTable=new char[26][26];
        createCipherTable(cipherTable);
        Character spaceChar = ' ';
        
        for(int i = 0; i < textToCode.length(); i++) {
            if( textToCode.charAt(i) == ' ' ){
                charEncodedMessage[i] = ' ';
                continue;
            }
            else if(Character.getNumericValue(textToCode.charAt(i)) > 35
                    || Character.getNumericValue(textToCode.charAt(i)) < 10 ){
                charEncodedMessage[i] = textToCode.charAt(i);
                continue;
            }
            
            
            int keyValue;
            if(Character.getNumericValue(encryptionKey.charAt(i)) > 35
                    || Character.getNumericValue(encryptionKey.charAt(i)) < 10){
                keyValue = 0;
            }
            else {
                keyValue = Character.getNumericValue(encryptionKey.charAt(i)) - 10; 
            }
            //Read char value and then get numeric value of character,
            // substitute by 10 (getNumericValue also reads values of 0-9 numbers)
            charEncodedMessage[i] = cipherTable[Character.getNumericValue(textToCode.charAt(i)) - 10][keyValue];
        }
        
        encodedMessage.setTextEncodedMessage(new String(charEncodedMessage));
//        encodedMessage = new String(charEncodedMessage);
    }
    
    /**
     * Gets the atribute encodedMessage.
     * @return Encoded message
     */
    public String getEncodedMessage(){
        return encodedMessage.getTextEncodedMessage();
    }
    
    /**
     * Gets the atribute textToCode.
     * @return String object with value of textToCode.
     */
    public String getTextToCode(){
        return this.textToCode;
    }
    
    /**
     * Sets the atribute textToCode. Additionally removes all spaces before proper textToCode.
     * @param text String value to be textToCode
     */
    public void setTextToCode(String text){
//        while(!text.isEmpty() && text.charAt(0) == ' '){
//            text = text.substring(1);
//        }
        
        
        this.textToCode = text.trim();
    }
    
    /**
     * Gets the value of attribute secretLetter
     * @return String object with value of secretLetter
     */
    public String getSecretLetter(){
        return this.secretLetter;
    }
    
    /**
     * Sets the attribute secretLetter.
     * @param secretLetter String value to be secretLetter
     */
    public void setSecretLetter(String secretLetter) throws EmptyStringException{
        if(secretLetter.isEmpty()){
            throw new EmptyStringException("Klucz niepoprawny!");
        }

        while(secretLetter.charAt(0) == ' ' 
                || Character.getNumericValue(secretLetter.charAt(0)) > 35
                || Character.getNumericValue(secretLetter.charAt(0)) < 10){

            secretLetter = secretLetter.substring(1);

            if(secretLetter.isEmpty()){
                throw new EmptyStringException("Klucz niepoprawny!");
            }
        }
        this.secretLetter = Character.toString(secretLetter.charAt(0));
    }
    
    /**
     * Initialize cipherTable with uppercase letters.
     * @param cipherTable Table to bo initialized
     */
    private void createCipherTable(char[][] cipherTable){
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                cipherTable[i][j]=(char)(65 + ((i+j) % 26));
            }
        }
    }
}

class EncodedMessage{
    private String textEncodedMessage;
    
    public EncodedMessage(){}
    
    public String getTextEncodedMessage(){
        return this.textEncodedMessage;
    }
    
    public void setTextEncodedMessage(String temp){
        this.textEncodedMessage = temp;
    }
}